/* This program controls the rotational speed and direction of
 * a DC motor.
 *
 * The Wytec EduPad board has a quad half-H-bridge motor driver,
 * which is capable of driving two DC motors or a stepper motor
 * with up to 15V and 1.2A continuous current.
 *
 * The enable pins of the half-bridges are connected to PORTB 3-0.
 * The PWM inputs are connected to PORTF 2 and PORTF 3.  These
 * pins are shared with the LEDs.  The PORTB pins are connected to
 * the LEDs on the EduBase board.  The PORTF pins are connected to
 * the LEDs on the Tiva LaunchPad.
 *
 * The four output pins of the motor driver device are connected to
 * the blue terminals marked M1, M2, M3, and M4.  Use of external
 * power supply for motor is recommended.  External power should be
 * connected to the terminal T3 and the jumper J4 should be at EXT.
 *
 * This program uses PORTB 3, 2 for direction control and PORTF 3 for
 * PWM control.  The outputs are terminals M3 and M4.
 * The PWM is generated by PWM1_3B.
 *
 * Built and tested with Keil MDK-ARM v5.24a and TM4C_DFP v1.1.0
 */
#include "tm4c123gh6pm.h"
#include "stdint.h"
#include "Timer0A.h"
#include "Timer2A.h"
#include "SSI2.h"
#include "LCD.h"
#include "PLL.h"


//void delayMs(int n);


int main(void) {

    PLL_Init(Bus8MHz);      // set system clock to 80 MHz
    Timer0A_Init(8000000);  // initialize Timer0A for 80 MHz clock
    SSI2_init();  // initialize SSI2 module for SPI
    LCD_init();   // initialize LCD controller

    int pw = 0;
    //int i = 0;

    Timer2A_Init();

    SYSCTL_RCGCPWM_R |= 0x02;        // enable clock to PWM1
    SYSCTL_RCGCGPIO_R |= 0x20;       // enable clock to GPIOF
    SYSCTL_RCGCGPIO_R |= 0x02;       // enable clock to GPIOB

    Timer0A_Wait1ms(1);                     // PWM1 seems to take a while to start

    SYSCTL_RCC_R &= ~0x00100000;     // use system clock for PWM
    PWM1_INVERT_R |= 0x80;           // positive pulse
    PWM1_3_CTL_R = 0;               // disable PWM1_3 during configuration
    PWM1_3_GENB_R = 0x0000080C;     // output high when load and low when match
    PWM1_3_LOAD_R = 3999;           // 4 kHz
    PWM1_3_CTL_R = 1;               // enable PWM1_3
    PWM1_ENABLE_R |= 0x80;           // enble PWM1

    GPIO_PORTF_DIR_R |= 0x08;             // set PORTF 3 pins as output (LED) pin
    GPIO_PORTF_DEN_R |= 0x08;             // set PORTF 3 pins as digital pins
    GPIO_PORTF_AFSEL_R |= 0x08;           // enable alternate function
    GPIO_PORTF_PCTL_R &= ~0x0000F000;     // clear PORTF 3 alternate function
    GPIO_PORTF_PCTL_R |= 0x00005000;      // set PORTF 3 alternate funtion to PWM

    GPIO_PORTB_DEN_R |= 0x0C;             // PORTB 3 as digital pins
    GPIO_PORTB_DIR_R |= 0x0C;             // set PORTB 3 as output
    GPIO_PORTB_DATA_R |= 0x08;            // enable PORTB 3

    while(1) {

//        for (i = 0 ; i < 10; i++) {
//            LCD_command(0x80);  // Move cursor back to 1st position
//            LCD_OutUFix(i);
//            Timer0A_Wait1ms(500);
//        }
//


        // set direction
        GPIO_PORTB_DATA_R &= ~0x04;
        GPIO_PORTB_DATA_R |= 0x08;
        // ramp up speed
        for (pw = 100; pw < 3999; pw += 20) {
            PWM1_3_CMPB_R = pw;
            Timer0A_Wait1ms(50);

            // get interval from Timer2A getInterval function
            uint32_t interval = Timer2A_getInterval();

            // output interval to LCD
            LCD_command(0x80);  // Move cursor back to 1st position
            LCD_OutUFix(interval);

        }
        // ramp down speed
        for (pw = 3900; pw >100; pw -= 20) {
            PWM1_3_CMPB_R= pw;
            Timer0A_Wait1ms(50);

            // get interval from Timer2A getInterval function
            uint32_t interval = Timer2A_getInterval();

            // output interval to LCD
            LCD_command(0x80);  // Move cursor back to 1st position
            LCD_OutUFix(interval);

        }

        // reverse direction
        GPIO_PORTB_DATA_R &= ~0x08;
        GPIO_PORTB_DATA_R |= 0x04;
        // ramp up speed
        for (pw = 100; pw < 3999; pw += 20) {
            PWM1_3_CMPB_R = pw;
            Timer0A_Wait1ms(50);

            // get interval from Timer2A getInterval function
            uint32_t interval = Timer2A_getInterval();

            // output interval to LCD
            LCD_command(0x80);  // Move cursor back to 1st position
            LCD_OutUFix(interval);
        }
        // ramp down speed
        for (pw = 3900; pw >100; pw -= 20) {
            PWM1_3_CMPB_R = pw;
            Timer0A_Wait1ms(50);

            // get interval from Timer2A getInterval function
            uint32_t interval = Timer2A_getInterval();

            // output interval to LCD
            LCD_command(0x80);  // Move cursor back to 1st position
            LCD_OutUFix(interval);
        }



    }
}

///* delay n milliseconds (50 MHz CPU clock) */
//void delayMs(int n) {
//    int i, j;
//    for(i = 0 ; i< n; i++)
//        for(j = 0; j < 6265; j++)
//            {}  /* do nothing for 1 ms */
//}
